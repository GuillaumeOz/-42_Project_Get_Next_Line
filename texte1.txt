Étant donné le chemin pathname d'un fichier, open() renvoie un descripteur de fichier, un petit entier positif ou nul utilisable par des appels système ultérieurs (read(2), write(2), lseek(2), fcntl(2), etc.). Le descripteur de fichier renvoyé par un appel réussi sera le plus petit descripteur de fichier non encore ouvert pour le processus.
Par défaut, le nouveau descripteur de fichier est configuré pour rester ouvert au travers d'un execve(2) (c'est-à-dire que l'attribut FD_CLOEXEC du descripteur de fichier, décrit dans fcntl(2), est initialement désactivé ; l'attribut O_CLOEXEC, spécifique à Linux, peut être utilisé pour modifier ce comportement par défaut ). Le pointeur de position dans le fichier est placé à son début (voir lseek(2)).

Un appel à open() crée une nouvelle description de fichier ouvert, une entrée dans la table des fichiers ouverts du système. Cette entrée enregistre la position dans le fichier et les attributs d'état du fichier (modifiable via l'opération F_SETFL de fcntl(2)). Un descripteur de fichier est une référence à l'une de ces entrées ; cette référence n'est pas affectée si pathname est ultérieurement supprimé ou modifié pour se référer à un fichier différent. La nouvelle description de fichier ouvert n'est initialement pas partagée avec un autre processus, mais ce partage peut survenir après un fork(2).

Le paramètre flags doit inclure l'un des mode d'accès suivants : O_RDONLY, O_WRONLY ou O_RDWR. Ceux-ci réclament respectivement l'ouverture du fichier en lecture seule, écriture seule, ou lecture-écriture. À cette valeur peut être ajouté zéro ou plusieurs attributs de création de fichier et attributs d'état de fichier avec un OU binaire. Les attributs de création de fichier sont O_CREAT, O_EXCL, O_NOCTTY et O_TRUNC. Les attributs d'état de fichier sont tous les autres attributs restant listés plus loin. La différence entre ces deux groupes d'attributs est que l'on peut récupérer et (dans certains cas) modifier avec fcntl(2) les attributs d'état de fichier. La liste complète des attributs de création de fichier et des attributs d'état de fichier est la suivante :

O_APPEND
Le fichier est ouvert en mode « ajout ». Initialement, et avant chaque write(2), la tête de lecture/écriture est placée à la fin du fichier comme avec lseek(2). Il y a un risque d'endommager le fichier lorsque O_APPEND est utilisé, sur un système de fichiers NFS, si plusieurs processus tentent d'ajouter des données simultanément au même fichier. Ceci est dû au fait que NFS ne supporte pas l'opération d'ajout de données dans un fichier, aussi le noyau du client est obligé de la simuler, avec un risque de concurrence des tâches.
O_ASYNC
Activer le pilotage d'entrées-sorties par signal : déclencher un signal (SIGIO par défaut, mais peut être changé via fcntl(2)) lorsque la lecture ou l'écriture deviennent possibles sur ce descripteur. Ceci n'est possible que pour les terminaux, pseudo-terminaux, sockets et (depuis Linux 2.6) tubes et FIFO. Voir fcntl(2) pour plus de détails.
O_CLOEXEC (Depuis Linux 2.6.23)
Activer l'attribut « close-on-exec » pour le nouveau descripteur de fichier. Spécifier cet attribut permet à un programme d'éviter une opération supplémentaire F_SETFD de fcntl(2) pour positionner l'attribut FD_CLOEXEC. De plus, l'utilisation de cet attribut est essentielle dans certains programmes multithreadés puisque l'utilisation d'une opération F_SETFD de fcntl(2) pour positionner l'attribut FD_CLOEXEC ne suffit pas pour éviter les conditions de concurrence lorsqu'un thread ouvre un descripteur de fichier en même temps qu'un autre thread effectue un fork(2) plus un execve(2).
O_CREAT
Créer le fichier s'il n'existe pas. Le possesseur (UID) du fichier est renseigné avec l'UID effectif du processus. Le groupe propriétaire (GID) du fichier est le GID effectif du processus ou le GID du répertoire parent (ceci dépend du système de fichiers, des options de montage, du mode du répertoire parent, etc.). Voir par exemple les options de montage bsdgroups et sysvgroups décrites dans la page mount(8)).
mode indique les permissions à utiliser si un nouveau fichier est créé. Cet argument doit être fourni lorsque O_CREAT est spécifié dans flags ; si O_CREAT n'est pas spécifié, mode est ignoré. Les permissions effectives sont modifiées par l'umask du processus de manière classique : les permissions du fichier créé sont (mode & ~umask). Veuillez noter que ce mode ne s'applique qu'aux accès ultérieurs au fichier nouvellement créé. L'appel open() qui crée un fichier dont le mode est en lecture seule fournira quand même un descripteur de fichier en lecture et écriture.

Les constantes symboliques suivantes sont disponibles pour mode :

S_IRWXU
00700 L'utilisateur (propriétaire du fichier) a les autorisations de lecture, écriture, exécution.
S_IRUSR
00400 L'utilisateur a l'autorisation de lecture.
S_IWUSR
00200 L'utilisateur a l'autorisation d'écriture.
S_IXUSR
00100 L'utilisateur a l'autorisation d'exécution.
S_IRWXG
00070 Le groupe a les autorisations de lecture, écriture, exécution.
S_IRGRP
00040 Le groupe a l'autorisation de lecture.
S_IWGRP
00020 Le groupe a l'autorisation d'écriture.
S_IXGRP
00010 Le groupe a l'autorisation d'exécution.
S_IRWXO
00007 Tout le monde a les autorisations de lecture, écriture, exécution.
S_IROTH
00004 Tout le monde a l'autorisation de lecture.
S_IWOTH
00002 Tout le monde a l'autorisation d'écriture.
S_IXOTH
00001 Tout le monde a l'autorisation d'exécution.
O_DIRECT (Depuis Linux 2.4.10)
Essayer de minimiser les effets du cache d'entrée-sortie sur ce fichier. Ceci dégradera en général les performances, mais est utilisé dans des situations spéciales, lorsque les applications ont leur propres caches. Les entrées-sorties dans le fichier se font directement depuis l'espace utilisateur, elles sont synchrones (à la fin de read(2) ou write(2), les données ont obligatoirement été transférées). Voir NOTES plus loin pour une discussion approfondie.